<!DOCTYPE html>
<html lang="en">
	<head>
		<title>KUJIKUJI | Interactive 3D Lottery</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<meta name="description" content="Interactive 3D lottery application built with Three.js">
		<meta name="author" content="siriz">
		<link type="text/css" rel="stylesheet" href="main.css">
		<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>


		<style>
			/* Page Layout */
			html, body {
				width: 100%;
				height: 100%;
				padding: 0;
				margin: 0;
				overflow: hidden;
			}
			
			body {
				color: #222;
			}
			
			/* Button Container */
			#wrapper {
				position: absolute;
				bottom: 20px;
				left: 50%;
				transform: translate(-50%, -50%);
				z-index: 100;
			}
			
			/* Main Button Styling */
			button {
				font-size: 30px;
				padding: 20px 40px;
				border-radius: 8px;
				border: 2px solid #333;
				background: rgba(255, 255, 255, 0.95);
				color: #333;
				font-weight: bold;
				box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
				cursor: pointer;
				visibility: visible;
				opacity: 1;
				transition: all 0.3s ease;
			}
			
			button:hover {
				transform: translateY(-2px);
				box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
				background: rgba(255, 255, 255, 1);
			}
			
			button:active {
				transform: translateY(0);
				box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
			}

			.hide {
				visibility: hidden;
				opacity: 0;
				transition: opacity 0.3s, visibility 0.3s;
			}
			
			/* Loading Indicator */
			.loading {
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				color: white;
				font-size: 24px;
				font-family: 'Arial', sans-serif;
			}
			
			/* Responsive Design */
			@media (max-width: 768px) {
				button {
					font-size: 24px;
					padding: 15px 30px;
				}
			}
		</style>
	</head>

	<body>
		
		<div id="wrapper">
			<button id="btn_select" class="hide">GO</button>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">
			/**
			 * KUJIKUJI - Interactive 3D Lottery Application
			 * Built with Three.js and GSAP for smooth animations
			 * 
			 * Features:
			 * - Multiple animated robot characters
			 * - Random selection with dramatic lighting
			 * - Smooth camera transitions
			 * - Character animations and interactions
			 */

			import * as THREE from 'three';
			import { FontLoader } from 'three/addons/loaders/FontLoader.js';
			import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import Stats from 'three/addons/libs/stats.module.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			// ===== Global Variables =====
			let container, stats, clock, gui;
			let camera, scene, renderer, controls;
			let sLight, dirLight, hemiLight, lightHelper;
			let modelGroup = [], kujiList = [];

			const api = { state: 'Standing' };
			const btnSelect = document.getElementById('btn_select');
			
			// ===== Animation States =====
			const states = [ 'Idle', 'Walking', 'Running', 'Dance', 'Sitting', 'Standing', 'Death' ];
			const emotes = [ 'Jump', 'Yes', 'No', 'Wave', 'Punch', 'ThumbsUp' ];

			// ===== Character Initial Positions =====
			const initPos = [
				{x: 0, z: 0, rot: 0},
				{x: 10, z: -20, rot: 45},
				{x: 15, z: -2, rot: 15},
				{x: -18, z: -7, rot: -45},
				{x: -10, z: -2, rot: -15},
				{x: -12, z: -17, rot: -15},
				{x: -2, z: -7, rot: -35},
				{x: -8, z: -27, rot: -145},
				{x: -7, z: 7, rot: 45},
				{x: 7, z: 2, rot: 145},
				{x: 12, z: -12, rot: 105},
				{x: 3, z: 8, rot: 35},
				{x: 6, z: -8, rot: -35},
				{x: -3, z: -18, rot: -70},
			];

			// ===== Character Names =====
			const nameList = [
				'HWANG1',
				'HWANG2',
				'HWANG3',
				'HWANG4',
				'HWANG5',
				'HWANG6',
				'HWANG7',
				'HWANG8',
				'HWANG9',
				'HWANG10',
				'HWANG11',
				'HWANG12',
				'HWANG13',
				'HWANG14',
			];
			
			// ===== Configuration =====
			THREE.Cache.enabled = true;

			const duration = 1;
			const ease = 'power3.out';
			const cameraInitPos = new THREE.Vector3(0, 20, 30);
			const cameraInitLookAt = new THREE.Vector3(0, 2, 0);
			
			// ===== Initialize Application =====
			init();

			/**
			 * Initialize the 3D scene, camera, lights, and models
			 */
			function init() {
				// Setup container
				container = document.createElement( 'div' );
				document.body.appendChild( container );

				// Setup camera
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 100 );
				camera.position.set( 0, 2000, 300 );
				camera.lookAt( cameraInitLookAt );

				// Animate camera to initial position
				gsap.to( camera.position, {
					duration: 4,
					ease: ease,
					x: cameraInitPos.x,
					y: cameraInitPos.y,
					z: cameraInitPos.z,
					onComplete: function() {
						btnSelect.classList.remove('hide')
					}, 
					delay: 0.0
				} );

				// Setup scene
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xe0e0e0 );
				scene.fog = new THREE.Fog( 0xe0e0e0, 0, 100 );

				clock = new THREE.Clock();

				// ===== Setup Lighting =====
				// Spotlight for dramatic effect (initially off)
				sLight = new THREE.SpotLight( 0xFFFFFF, 60, 125, Math.PI / 16, 0.25, 1 );
				sLight.castShadow = true;
				sLight.intensity = 0;
				scene.add( sLight );
				scene.add( sLight.target );

				// Hemisphere light for ambient lighting
				hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 3 );
				hemiLight.position.set( 0, 20, 0 );
				scene.add( hemiLight );

				// Directional light for shadows
				dirLight = new THREE.DirectionalLight( 0xffffff, 3 );
				dirLight.position.set( 0, 20, 10 );
				dirLight.castShadow = true; 
				dirLight.shadow.camera.right = 120;
				dirLight.shadow.camera.left = -120;
				dirLight.shadow.camera.top = -120;
				dirLight.shadow.camera.bottom = 120;
				dirLight.shadow.mapSize.width = 1024;
				dirLight.shadow.mapSize.height = 1024;
				dirLight.shadow.camera.near = 0.5;
				dirLight.shadow.camera.far = 500;
				scene.add( dirLight );

				// ===== Setup Ground =====
				const mesh = new THREE.Mesh( 
					new THREE.BoxGeometry( 500, 500, 0.01 ), 
					new THREE.MeshPhysicalMaterial( { color: 0xcbcbcb, roughness: 0, depthWrite: true } ) 
				);
				mesh.rotation.x = - Math.PI / 2;
				mesh.receiveShadow = true;
				scene.add( mesh );

				// Grid helper
				const grid = new THREE.GridHelper( 200, 40, 0x000000, 0x000000 );
				grid.material.opacity = 0.1;
				grid.material.transparent = true;
				scene.add( grid );

				// ===== Load Models =====
				for ( let i = 0; i < initPos.length; i ++ ) {
					loadModel(i);	
				}

				// ===== Setup Renderer =====
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				container.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize );

				// ===== Setup Controls =====
				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.autoRotate = true;
				controls.maxPolarAngle = Math.PI * 80 / 180;

				// ===== Setup Button Event =====
				btnSelect.status = 1;
				let currentIdx = -1;
				let timeStamp = 0;
				
				btnSelect.addEventListener('click', (e)=>{
					// Prevent rapid clicking
					if ( new Date() * 1 - timeStamp < 1000 ) {
						return;
					}
					
					if ( btnSelect.status === 1 ) {
						// Select random character
						currentIdx = kujiList[parseInt( Math.random() * kujiList.length )];
						selectedKuji(currentIdx);
					}
					else if ( btnSelect.status === 2 ) {
						// Return to overview
						returnView(currentIdx);
					}

					timeStamp = new Date() * 1;
				})
			}

			/**
			 * Return to overview after selecting a character
			 * @param {number} selectedIdx - Index of the selected character
			 */
			function returnView(selectedIdx) {
				btnSelect.classList.add('hide');
				controls.autoRotate = true;

				let model = modelGroup[selectedIdx];
				model.status = 'dead';

				clearTimeout(model.interval);

				// Play death animation
				model.activeAction = model.actions[ states[6] ];
				model.action = model.actions[ states[6] ];
				model.action.loop = THREE.LoopOnce;
				model.action.play();

				// Fade out spotlight
				gsap.to(sLight, {
					intensity: 0,
					duration: duration,
					ease: ease
				})
				
				// Restore normal lighting
				gsap.to(dirLight, {
					intensity: 3,
					duration: duration,
					ease: ease,
					onUpdate: function() {
						hemiLight.intensity = dirLight.intensity
					}
				})

				// Restore background color
				gsap.to(scene.background, {
					r: 0.8, g: 0.8, b: 0.8,
					duration: duration,
					ease: ease,
					onUpdate: function() {
						scene.fog.color = scene.background;
					}
				})

				// Return camera to initial position
				gsap.to( camera.position, {
					duration: duration,
					ease: ease,
					x: cameraInitPos.x,
					y: cameraInitPos.y,
					z: cameraInitPos.z,
					onUpdate: function() {
						camera.lookAt( cameraInitLookAt );
						controls.target = cameraInitLookAt;
					},
					onComplete: function() {
						btnSelect.classList.remove('hide');
						btnSelect.textContent = 'GO';
						btnSelect.status = 1;
					},
					delay: 0.5
				} );
			}

			/**
			 * Handle character selection with dramatic effects
			 * @param {number} selectedIdx - Index of the selected character
			 */
			function selectedKuji( selectedIdx ) {
				// Remove selected character from available list
				let killIdx = kujiList.indexOf(selectedIdx);
				if ( killIdx > -1 ) {
					kujiList.splice(killIdx, 1);
				}

				btnSelect.classList.add('hide');
				controls.autoRotate = false;

				let model = modelGroup[selectedIdx];
				model.status = 'showing';

				// Focus spotlight on selected character
				changeSpotLightPosition(selectedIdx);
				
				// Darken background for dramatic effect
				gsap.to(scene.background, {
					r: 0, g: 0, b: 0,
					duration: duration,
					ease: ease,
					onUpdate: function() {
						scene.fog.color = scene.background;
					}
				})

				// Turn on spotlight
				gsap.to(sLight, {
					intensity: 160,
					duration: duration,
					ease: ease
				})
				
				// Dim other lights
				gsap.to(dirLight, {
					intensity: 0.03,
					duration: duration,
					ease: ease,
					onUpdate: function() {
						hemiLight.intensity = dirLight.intensity
					}
				})

				// Calculate model bounds for camera positioning
				var aabb = new THREE.Box3().setFromObject( model );
				var center = aabb.getCenter( new THREE.Vector3() );
				var size = aabb.getSize( new THREE.Vector3() );

				// Move camera to focus on selected character
				gsap.to( camera.position, {
					duration: duration,
					ease: ease,
					x: center.x,
					y: center.y,
					z: center.z + size.z + 6,
					onUpdate: function() {
						camera.lookAt( center );
						controls.target = center;
					},
					onComplete: function() {
						// Play random emote
						fadeToAction(emotes[parseInt(Math.random() * emotes.length - 1)], 0.5, model);
						
						// After 2 seconds, flip name card and show thumbs up
						setTimeout(function(){
							fadeToAction(emotes[5], 0.5, model);

							gsap.to(model.title.rotation, {
								z: Math.PI / 2,
								duration: 0.4,
								onComplete: function() {
									model.title_index.visible = false;
									model.title_name.visible = true;
									gsap.to(model.title.rotation, {
										z: Math.PI,
										duration: 0.4
									})
								}
							})
						}, 2000)
						
						// Show return button after 3 seconds
						setTimeout(function(){
							btnSelect.classList.remove('hide');
						}, 3000)
						
						btnSelect.textContent = 'RETURN';
						btnSelect.status = 2;
					}
				} );

				// Face model forward
				gsap.to( model.rotation, {
					duration: duration,
					ease: ease,
					y: 0
				});
			}

			/**
			 * Position spotlight on specific character
			 * @param {number} idx - Character index
			 */
			function changeSpotLightPosition(idx) {
				let model = modelGroup[idx];
				sLight.position.set(model.position.x, 30, model.position.z + 20)
				sLight.target = model;
			}

			/**
			 * Load 3D character model
			 * @param {number} idx - Model index
			 */
			function loadModel(idx) {
				const loader = new GLTFLoader();
				loader.load( 'models/gltf/RobotExpressive/RobotExpressive.glb', function ( gltf ) {
					const model = gltf.scene;
					
					// Enable shadows for all meshes
					model.traverse( function( node ) {
						if ( node.isMesh ) { 
							node.castShadow = true; 
							node.receiveShadow = true; 
						}
					} );

					// Hide head component
					model.getObjectByName( 'Head_4' ).visible = false;

					// Add indicator plane
					const geometry = new THREE.PlaneGeometry( 0.02, 0.02 );
					const material = new THREE.MeshPhysicalMaterial( {color: 0xffff00, side: THREE.DoubleSide} );
					const plane = new THREE.Mesh( geometry, material );
					plane.rotation.x = Math.PI * 90 / 180;
					plane.position.y = -0.015;
					model.getObjectByName( 'Head_3' ).add( plane );

					// Load and add text labels
					const fontLoader = new FontLoader();
					fontLoader.load( 'fonts/optimer_bold.typeface.json', function ( response ) {
						model.title = new THREE.Object3D();
						model.title_index = getTextMesh(response, (idx + 1).toString(), false);
						model.title_name = getTextMesh(response, nameList[idx], true);
						model.title.add( model.title_index );
						model.title.add( model.title_name );
						model.getObjectByName( 'Head_3' ).add(model.title)
					} );

					// Setup animation mixer
					const mixer = new THREE.AnimationMixer( model );
					modelGroup.push(model);
					kujiList.push(idx);
					scene.add( model );

					model.idx = idx;
					model.mixer = mixer;

					// Set initial position and rotation
					model.position.set(
						initPos[idx].x,
						0,
						initPos[idx].z
					);
					model.rotation.y = Math.PI * initPos[idx].rot / 180;

					// Setup animations
					model.actions = {};
					for ( let i = 0; i < gltf.animations.length; i ++ ) {
						const clip = gltf.animations[ i ];
						const action = mixer.clipAction( clip );
						model.actions[ clip.name ] = action;

						if ( emotes.indexOf( clip.name ) >= 0 || states.indexOf( clip.name ) >= 4 ) {
							action.clampWhenFinished = true;
							action.loop = THREE.LoopOnce;
						}
					}

					// Start with default animation
					model.activeAction = model.actions[ api.state ];
					model.activeAction.play();

					// Start random animation loop
					model.interval = setTimeout(randAnimation, 1000 * Math.random());

					/**
					 * Play random animations on characters
					 */
					function randAnimation() {
						if ( !model.status ) {
							let rand = parseInt( Math.random() * 10);
							let type = parseInt( Math.random() * 4);

							if ( rand < 8 ) {
								fadeToAction(states[type], 0.5, model);
							}
						}
						else if ( model.status === 'dead' ) {
							clearTimeout(model.interval);
							return;
						}

						if ( model.status !== 'dead' ) {
							model.interval = setTimeout(randAnimation, 10000 * Math.random());
						}
					}

				}, undefined, function ( e ) {
					console.error( e );
				} );
			}

			/**
			 * Create 3D text mesh for character labels
			 * @param {Object} font - Loaded font object
			 * @param {string} title - Text to display
			 * @param {boolean} reverse - Whether to flip the text
			 * @returns {THREE.Mesh} Text mesh object
			 */
			function getTextMesh(font, title, reverse) {
				const textGeo = new TextGeometry( title, {
					font: font,
					size: 0.005,
					depth: 0.001,
					curveSegments: 0.01,
					bevelThickness: 0.01,
					bevelSize: 0.0,
					bevelEnabled: false
				} );

				textGeo.computeBoundingBox();

				var centerOffset = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

				const materials = [
					new THREE.MeshPhongMaterial( { color: 0xFF6600, flatShading: true } ),
					new THREE.MeshPhongMaterial( { color: 0xFF6600 } )
				];
				
				const textMesh = new THREE.Mesh( textGeo, materials );
				textMesh.rotation.x = Math.PI * 90 / 180;
				
				if ( reverse === true ) {
					textMesh.position.x = -centerOffset;
					textMesh.rotation.y = Math.PI;
					textMesh.visible = false;
				}
				else {
					textMesh.position.x = centerOffset;
				}
				textMesh.position.z = 0.015;

				return textMesh;
			}

			/**
			 * Smoothly transition between animations
			 * @param {string} name - Animation name
			 * @param {number} duration - Transition duration
			 * @param {Object} model - Character model
			 */
			function fadeToAction( name, duration, model ) {
				model.previousAction = model.activeAction;
				model.activeAction = model.actions[ name ];

				if ( model.previousAction !== model.activeAction ) {
					model.previousAction.fadeOut( duration );
				}

				model.activeAction
					.reset()
					.setEffectiveTimeScale( 1 )
					.setEffectiveWeight( 1 )
					.fadeIn( duration )
					.play();
			}

			/**
			 * Handle window resize
			 */
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			/**
			 * Animation loop
			 */
			function animate() {
				const dt = clock.getDelta();

				if ( modelGroup && modelGroup.length > 0 ) {
					for ( let i = 0, len = modelGroup.length; i < len; i ++ ){
						modelGroup[i].mixer.update(dt);
					}
				}

				renderer.render( scene, camera );
				controls.update();
			}

		</script>

	</body>
</html>
